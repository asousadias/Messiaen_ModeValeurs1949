; OM File Header - Saved 2020/04/29 20:56:37
; (6.16 :patc (om-make-point 24 24) (om-make-point 297 23) (om-make-point 719 658) "" 183 0 nil "2020/04/29 20:56:37")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "constr_rtm" (quote ((let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 344 454) (om-make-point 25 36) 16 "16" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch1" (om-load-patch-abs1 "durs_tempo" (quote ((let ((box (om-load-boxcall (quote genfun) "OM*1" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 250 213) (om-make-point 77 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-ROUND1" (quote om-round) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1))) (om-make-point 262 253) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output2" 2 (om-make-point 427 319) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "tempo" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input3" 3 (om-make-point 421 20) "no documentation" "used_tempo" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-ROUND" (quote om-round) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1))) (om-make-point 121 248) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 109 208) (om-make-point 77 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 350 324) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "l_durs" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 124 320) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "l_off" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input2" 2 (om-make-point 329 20) "no documentation" "coef_durs" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 202 23) "no documentation" "l_durs" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 90 24) "no documentation" "l_offs" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((9 0 0 0 nil 0) (8 0 0 1 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (5 0 4 0 nil 0) (10 0 5 0 nil 0) (8 0 5 1 nil 0) (1 0 6 0 nil 0) (4 0 7 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 601 428)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input2" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input3" nil))) (om-make-point 267 132) (om-make-point 208 61) nil nil "durs_tempo"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMQUANTIFY" (quote omquantify) (quote ((om-load-inputfun (quote input-funbox) "durations" "DURS" (list 100)) (om-load-inputfun (quote input-funbox) "Tempo" "TEMPI" 60) (om-load-inputfun (quote input-funbox) "measures" "MEASURES" (list 4 4)) (om-load-inputfun (quote input-funbox) "maximum division" "MAX/" 8))) (om-make-point 208 472) (om-make-point 100 53) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" 0))) (om-make-point 136 192) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 47 116) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil) (om-load-inputfun (quote input-funbox) "else" "ELSE" nil))) (om-make-point 34 393) (om-make-point 165 53) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM>" (quote om>) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 0))) (om-make-point 29 224) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 88 331) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" -1))) (om-make-point 77 223) (om-make-point 40 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "calculate durs" (quote ((let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "the list" "MATRIX" nil))) (om-make-point 164 176) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 88 312) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil))) (om-make-point 174 261) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 97 82) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 287 209) (om-make-point 38 27) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 248 259) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH1" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 1) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 60 162) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "N" "N" 0) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 133 158) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM>=" (quote om>=) (quote ((om-load-inputfun (quote input-funbox) "a number" "SELF" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM" 1))) (om-make-point 25 294) (om-make-point 74 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "if" "TEST" nil) (om-load-inputfun (quote input-funbox) "then" "ACTION" nil) (om-load-inputfun (quote input-funbox) "else" "ELSE" nil))) (om-make-point 53 356) (om-make-point 243 53) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 149 419) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 17 40) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 318 414) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 21 422) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((8 0 0 0 nil 0) (3 0 1 0 nil 0) (4 0 1 1 nil 0) (3 0 2 0 nil 0) (1 0 2 1 nil 0) (0 0 3 1 nil 0) (0 0 4 1 nil 0) (3 0 5 0 nil 0) (4 0 5 1 nil 0) (5 0 6 0 nil 0) (4 0 6 1 nil 0) (2 0 6 2 nil 0) (6 0 7 0 nil 0) (7 1 9 0 nil 0) (7 0 10 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first list" "L1?" nil) (om-load-inputfun (quote input-funbox) "second list" "L2?" nil))) (om-make-point 169 100) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST1" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 246 69) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 121 64) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 165 339) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 270 4) "no documentation" "durs" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 72 8) "no documentation" "onsets" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (2 0 1 0 nil 0) (0 0 2 0 nil 0) (5 0 3 0 nil 0) (4 0 3 1 nil 0) (7 0 4 0 nil 0) (8 0 5 0 nil 0) (1 0 6 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 400 500)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil))) (om-make-point 147 258) (om-make-point 190 61) nil nil "calculate durs"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 330 68) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input5" 5 (om-make-point 315 384) "measures" "mesure" (list 4 4) nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output2" 2 (om-make-point 548 470) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "tempo" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output1" 1 (om-make-point 415 475) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "chord_obj" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 86 534) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) "rtm_tree" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input4" 4 (om-make-point 451 58) "tempo pretendu" "tempo" 60 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input3" 3 (om-make-point 378 43) "coef de duree
" "coef_durs" 1.0 nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "l_durs" 2 (om-make-point 319 10) "no documentation" "l_durs" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "l_onsets" 1 (om-make-point 246 58) "no documentation" "l_onsets" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord_obj" 0 (om-make-point 417 394) "chord object" "chord_obj" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((18 0 1 0 nil 0) (10 0 1 1 nil 0) (16 0 1 2 nil 0) (15 0 1 3 nil 0) (5 0 2 0 nil 0) (1 2 2 1 nil 0) (11 0 2 2 nil 0) (0 0 2 3 nil 0) (1 0 3 0 nil 0) (1 0 4 0 nil 0) (6 0 5 0 nil 0) (7 0 5 1 nil 0) (9 0 5 2 nil 0) (4 0 6 0 nil 0) (8 0 7 0 nil 0) (9 0 7 1 nil 0) (4 0 8 0 nil 0) (3 0 9 0 nil 0) (1 1 9 1 nil 0) (17 0 10 0 nil 0) (1 2 12 0 nil 0) (19 0 13 0 nil 0) (2 0 14 0 nil 0))) nil 6.16))
